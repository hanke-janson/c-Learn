#include <iostream>

// 在编译之前，每个代码 (.cpp) 文件都会经过一个预处理阶段
// 在此阶段，称为预处理器的程序对代码文件的文本进行各种更改
// 预处理器实际上不会以任何方式修改原始代码文件――相反，预处理器所做的所有更改都临时发生在内存中或使用临时文件
// 预处理时：去除注释，并确保每个代码文件以换行符结尾

// 当预处理器完成处理代码文件时，结果称为翻译单元，这个翻译单元是由编译器编译的
// 预处理、编译和链接的整个过程称为翻译

// 当预处理器运行时，它会扫描代码文件（从上到下），寻找预处理器指令
// 预处理器指令（通常简称为directives）是以#符号开头并以换行符（不是分号）结尾的指令
// 这些指令告诉预处理器执行某些文本操作任务
// 预处理器不理解 C++ 语法――相反，指令有自己的语法（在某些情况下类似于 C++ 语法，而在其他情况下，则不太相似）

// 当您#include一个文件时，预处理器会用包含文件的内容替换#include指令
// 然后对包含的内容进行预处理（连同文件的其余部分），然后进行编译

// 宏定义
// #define指令可用于创建宏。在 C++ 中，宏是定义如何将输入文本转换为替换输出文本的规则
// 有两种基本类型的宏：类对象宏和类函数宏
// 类函数宏的行为类似于函数，并且具有相似的目的，通常被认为是危险的，它们几乎可以做通过一个正常的函数来完成的任何事情

// 建议完全避免使用这些类型的宏
// 带有替换文本的类对象宏
#define MY_NAME "Alex"

// 没有替换文本的类对象宏
// 标识符的任何一步出现都将被删除并替换为任何东西！
#define PRINT_JOE

// 条件编译
// 条件编译预处理器指令允许您指定在什么条件下编译或不编译 常用的：#ifdef、#ifndef和#endif
// #ifndef与#ifdef相反，它允许您检查标识符是否尚未#defined。

int foo()
{
	std::cout << "My name is " << MY_NAME << '\n';
#ifdef PRINT_JOE
	std::cout << "Joe\n";
#endif

#ifdef PRINT_BOB
	std::cout << "Bob\n";
#endif
	// 条件编译的一个更常见的用途是使用#if 0将代码块排除在编译之外（就像它在注释块中一样）
#if 0 // 0 不要从这里开始编译任何东西 1 这里的代码会被编译
	std::cout << "Bob\n";
	std::cout << "Steve\n";
#endif // 0
	// 类对象宏不影响其他预处理器指令

	// #defines 的范围
	// 指令在编译前解析，逐个文件地从上到下解析
	// 预处理器完成后，该文件中所有定义的标识符都将被丢弃
	// 这意味着指令仅从定义点到定义它们的文件末尾有效
	// 一个代码文件中定义的指令不会影响同一项目中的其他代码文件
	return 0;
}